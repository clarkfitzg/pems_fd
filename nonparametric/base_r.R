# Tue Mar  6 09:03:53 PST 2018
# I'm writing this as an example of where I would like the code analysis to
# start.

# These first two functions could just as well be in a package.

dyncut = function(x, pts_per_bin = 200, lower = 0, upper = 1, min_bin_width = 0.01)
{
    x = x[x < upper]
    N = length(x)
    max_num_cuts = ceiling(upper / min_bin_width)
    eachq = pts_per_bin / N

    possible_cuts = quantile(x, probs = seq(from = 0, to = 1, by = eachq))
    cuts = rep(NA, max_num_cuts)
    current_cut = lower
    for(i in seq_along(cuts)){
        # Find the first possible cuts that is at least min_bin_width away from
        # the current cut
        possible_cuts = possible_cuts[possible_cuts >= current_cut + min_bin_width]
        if(length(possible_cuts) == 0) 
            break
        current_cut = possible_cuts[1]
        cuts[i] = current_cut
    }
    cuts = cuts[!is.na(cuts)]
    c(lower, cuts, upper)
}

# Non parametric binned means
npbin = function(x)
{
    breaks = dyncut(x$occupancy2, pts_per_bin = 200)
    binned = cut(x$occupancy2, breaks, right = FALSE)
    groups = split(x$flow2, binned)

    out = data.frame(station = rep(x[1, "station"], length(groups))
        , right_end_occ = breaks[-1]
        , mean_flow = sapply(groups, mean)
        , sd_flow = sapply(groups, sd)
        , number_observed = sapply(groups, length)
    )
    out
}
       

# Code analysis is really on these two lines
pems2 = pems[, c("station", "flow2", "occupancy2")]
fd_shape = by(pems2, pems2[, "station"], npbin)

# OR, maybe easier to start with it in this form:
fd_shape = by(data = pems[, c("station", "flow2", "occupancy2")]
              , INDICES = pems2[, "station"]
              , FUN = npbin
              )

# Here's dplyr
pems2 = select(pems, station, flow2, occupancy2)
groups = group_by(pems2, station)
do(groups, npbin(.))

# Given the code and whatever information about the input_table we need,
# ie. column names and classes, the code analysis needs to infer the
# following things:
#
# - cluster_by = "station"
#       Comes from analyzing by()
# - input_table = "pems"
#       A free variable we're treating as a data frame
# - input_cols = c("station", "flow2", "occupancy2")
#       Column use inference, already can do that
# - output_table = "fd_shape"
#       The only assignment that we want to keep
# - output_cols = c("station", "right_end_occ", "mean_flow", "sd_flow", "number_observed")
#       From analyzing the return value of npbin
# - output_classes = c("integer", "numeric", "numeric", "numeric", "integer")
#       Need general type inference for this
